<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="随笔,">










<meta name="description" content="从https://github.com/rspivak/lsbasi看到了这篇文章，它不仅深入浅出地讲述了怎么从头写一个编译器、解释器，其中有不少闪光的观点值得品味。">
<meta name="keywords" content="随笔">
<meta property="og:type" content="article">
<meta property="og:title" content="编写编译器和解释器一">
<meta property="og:url" content="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/index.html">
<meta property="og:site_name" content="Palance&#39;s Blog">
<meta property="og:description" content="从https://github.com/rspivak/lsbasi看到了这篇文章，它不仅深入浅出地讲述了怎么从头写一个编译器、解释器，其中有不少闪光的观点值得品味。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/img01.png">
<meta property="og:image" content="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/img02.png">
<meta property="og:image" content="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/img03.png">
<meta property="og:image" content="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/img04.png">
<meta property="og:image" content="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/img05.png">
<meta property="og:image" content="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/img06.png">
<meta property="og:updated_time" content="2019-08-14T03:46:29.346Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="编写编译器和解释器一">
<meta name="twitter:description" content="从https://github.com/rspivak/lsbasi看到了这篇文章，它不仅深入浅出地讲述了怎么从头写一个编译器、解释器，其中有不少闪光的观点值得品味。">
<meta name="twitter:image" content="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/img01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/">





  <title>编写编译器和解释器一 | Palance's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e9c9a05f15583e8039e36cfe85103e96";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Palance's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Palance Li">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/13184524">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Palance's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">编写编译器和解释器一</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-18T14:00:00+08:00">
                2018-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编译器/" itemprop="url" rel="index">
                    <span itemprop="name">编译器</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/18/2018/0618BuildASimpleInterpreter1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/06/18/2018/0618BuildASimpleInterpreter1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>从<br><a href="https://github.com/rspivak/lsbasi" target="_blank" rel="noopener">https://github.com/rspivak/lsbasi</a><br>看到了这篇文章，它不仅深入浅出地讲述了怎么从头写一个编译器、解释器，其中有不少闪光的观点值得品味。</p>
<a id="more"></a>
<p>文章系列共14篇，首篇开头就引入<a href="http://steve-yegge.blogspot.com/" target="_blank" rel="noopener">Steve Yegge</a>牛的一句话——“如果你不知道编译器是如何工作的，你就不会理解计算机是如何工作的。如果你不能100%确认你深刻理解编译器的工作原理，那么你多半是不理解的”。关于<a href="http://steve-yegge.blogspot.com/" target="_blank" rel="noopener">Steve Yegge</a>又是一个有意思的大牛，他有很多博客文章被翻译成中文。</p>
<h1 id="我为什么关注它？"><a href="#我为什么关注它？" class="headerlink" title="我为什么关注它？"></a>我为什么关注它？</h1><p>通常学习一门技能都会被教育为什么要学习，而我一般都不看这类陈述，一方面因为我在学习之前对于为什么要学已经想得很清楚，另一方面这类描述像拉客的广告一样没啥新意。但在这篇文章里关于“为什么”我还是读了两遍：</p>
<ol>
<li>写一个编译器和解释器，需要组合使用很多种技术，这些技术在写任何软件的时候都是有用的。这有助于你提升这些技能，并成为更牛逼的软件工程师。</li>
<li>帮助你深刻理解计算机是如何工作的。编译器和解释器在外部看来就像魔术一样，但是你不应该满足于这种境界，而应该揭开构建它们的神秘面纱，理解内部机制让一切尽在掌控。</li>
<li>如果你要创建自己的编程语言，或者特定领域的编程语言，你就必须自己写解释器和编译器。最近新的编程语言不断涌现，Elixir, Go, Rust等等。</li>
</ol>
<p>第1点是我在读完全部文章后感同身受的，本来不打算在这个层面花太多精力，因为我在今年学习的路线图是机器学习，了解编译器是为了解决iOS下使用OC热更新的问题。但是读了这一系列的文章之后，不仅决定再深入精读一遍，还有必要跟着一起动手玩玩，这是一段有趣、有料的旅程。</p>
<p>第3点听起来有点牵强，尽管编程语言层出不穷，但这世界上需要自己设计编程语言并且有价值的仍是凤毛麟角。但最近还真是遇到了这类的挑战——我的目标不是设计一门被广泛应用的编程语言，而是要设计一个OC的编译器和解释器，以支持iOS下代码的热更新。</p>
<h1 id="什么是编译器和解释器？"><a href="#什么是编译器和解释器？" class="headerlink" title="什么是编译器和解释器？"></a>什么是编译器和解释器？</h1><p>翻译器和解释器的作用都是将高级语言写的源代码翻译成更低级的形式。<strong>编译器Compiler</strong>直接将它翻译成机器语言，而<strong>解释器Interpreper</strong>则是将它翻译成介于高级语言和机器语言的中间形式。参考《计算机系统要素——从零开始构建现代计算机》的插图：<br><img src="/2018/06/18/2018/0618BuildASimpleInterpreter1/img01.png" alt></p>
<p>图中的<strong>编译器+虚拟机+汇编编译器</strong>是本文说的编译器，图中的<strong>编译器</strong>是本文中的解释器。</p>
<p>解释器处理代码的完整流程如下：</p>
<p><img src="/2018/06/18/2018/0618BuildASimpleInterpreter1/img02.png" alt><br><strong>词法分析lexical analyzer</strong>是将输入的字符流分割成token，这是解释其处理代码的第一步，它将输入字符流转成token流。<br><strong>token</strong>是具有类型和值的对象，用来描述编译后的基本单位。<br><strong>词位lexeme</strong>是形成一个token的字符序列。<br>从token流中查找符合预期的语法结构的过程称为<strong>解析parsing</strong>也称为<strong>语法分析syntax analysis</strong>，执行解析的部分称为<strong>解析器parser</strong>也称为<strong>语法分析器syntax analyzer</strong>。</p>
<h1 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h1><p>函数<code>Interpreper::get_next_token()</code>承担<strong>词法分析器lexical analyzer</strong>的角色，每次调用从输入字符流中解析一个token并返回：<br><img src="/2018/06/18/2018/0618BuildASimpleInterpreter1/img03.png" alt></p>
<p>在Part1中，主逻辑写在函数<code>Interpreper::expr()</code>中：<br><img src="/2018/06/18/2018/0618BuildASimpleInterpreter1/img04.png" alt><br><code>Interpreper::get_next_token()</code>负责解析一个token，<code>Interpreper::eat(...)</code>负责确认该token是否符合预期，并执行下一次<code>Interpreper::get_next_token()</code>。<br><code>Interpreper::expr()</code>承担<strong>语法分析器syntax analyzer</strong>的角色，它写死了解析的顺序是：<code>INTEGER - PLUS - INTEGER</code>——这就是符合预期的语法规范。将<code>get_next_token()</code>和<code>eat(...)</code>分开是为了将词法分析和语法分析分离——词法分析只关注输入串的合法性，而语法分析则关注token流的顺序是否符合业务逻辑。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">''' 只负责解析出一个合法的Token字串 '''</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> current_char.isdigit():</span><br><span class="line">            token = Token(INTEGER, int(current_char))</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_char == <span class="string">'+'</span>:</span><br><span class="line">            token = Token(PLUS, current_char)</span><br><span class="line">            self.pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> token</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        <span class="string">''' 如果dangqianToken符合预期，则继续执行词法分析 '''</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.get_next_token()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">''' 以此获取：INTEGER - PLUS - INTEGER，完成计算 '''</span></span><br><span class="line">        ...</span><br><span class="line">        self.current_token = self.get_next_token()</span><br><span class="line">        ...</span><br><span class="line">        left = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        ...</span><br><span class="line">        op = self.current_token</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">        ...</span><br><span class="line">        right = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        ...</span><br><span class="line">        result = left.value + right.value</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<h2 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h2><p>在第二篇中添加了三个功能：<br>①处理空格<br>②支持多位数字<br>③支持减法<br>显然这三部分都与词法分析器相关。在<code>Interpreper::get_next_token()</code>过程中如果发现当前符号是空格，就继续向后解析；如果发现是数字，则继续向后解析，直到非数字，再把刚刚缓存的字窜转成数值；如果发现是符号<code>-</code>，则返回Token。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span> <span class="comment"># ①</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isspace():</span><br><span class="line">        self.advance()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span>          <span class="comment"># ②它和①的实现非常相似</span></span><br><span class="line">    ...</span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.current_char.isdigit():</span><br><span class="line">        result += self.current_char</span><br><span class="line">        self.advance()</span><br><span class="line">    <span class="keyword">return</span> int(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">            self.skip_whitespace()   <span class="comment"># ①</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">            <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>: <span class="comment"># ③</span></span><br><span class="line">            self.advance()</span><br><span class="line">            <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>最后在<code>Interpreper::expr()</code>中更新语义分析逻辑：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line">    ...</span><br><span class="line">    left = self.current_token</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    ...</span><br><span class="line">    op = self.current_token</span><br><span class="line">    <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">        self.eat(PLUS)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.eat(MINUS) <span class="comment"># 支持减号运算</span></span><br><span class="line">    ...</span><br><span class="line">    right = self.current_token</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> op.type == PLUS:</span><br><span class="line">        result = left.value + right.value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = left.value - right.value</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<h1 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h1><p>学习词法分析器时已经接触到了语法分析器<code>Interpreper::expr()</code>，那是一个极其简陋的版本，它hard code了“整型数 → 加/减 → 整型数”的语法逻辑。在文章的<a href="https://ruslanspivak.com/lsbasi-part3/" target="_blank" rel="noopener">Part3</a>对语法分析器做了扩展，使之支持没有括号的整型数值的加减运算：</p>
<p><img src="/2018/06/18/2018/0618BuildASimpleInterpreter1/img05.png" alt><br>由于只涉及到语法规则的变化，因此在代码上只需要修改语法分析器即可。这里就显示出了把词法、语法分开的好处。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">''' 只接受INTEGER一种term '''</span></span><br><span class="line">    token = self.current_token</span><br><span class="line">    self.eat(INTEGER)</span><br><span class="line">    <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    self.current_token = self.get_next_token()</span><br><span class="line"></span><br><span class="line">    result = self.term()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">            self.eat(PLUS)</span><br><span class="line">            result = result + self.term()</span><br><span class="line">        <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">            result = result - self.term()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>而且语法分析器的代码和语法图是直接对应的，非常直观。</p>
<h1 id="上下文无关文法和BNF表示法"><a href="#上下文无关文法和BNF表示法" class="headerlink" title="上下文无关文法和BNF表示法"></a>上下文无关文法和BNF表示法</h1><p><code>上下文无关语法context-free grammars</code>或<code>BNF（Backus-Naur Form）表示法</code>是一套用来表示语法规则的协议，形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr    : factor((MUL|DIV) factor)*</span><br><span class="line">factor  : INTEGER</span><br></pre></td></tr></table></figure></p>
<p>BNF表示法的优点在于：它更紧凑，也是更文档化的表述方式，从该表述法到代码的转换比较容易。<br>如上例所示，一个语法由一系列规则组成。一条规则冒号左端由一个非终结符组成，称为<strong>头部</strong>或<strong>左侧</strong>，冒号右端由一系列终结符或非终结符组成，称为<strong>主体</strong>或<strong>右侧</strong>。<br>上例中像MUL, DIV和INTEGER这样的变量称为<strong>终结符</strong>，像exp, factor这样的变量称为<strong>非终结符</strong>。<br>第一条规则左侧的非终结符称为<strong>开始符号</strong>，上例中的开始符号是expr。<br>本文使用的BNF表示法是一类变种，其中的符号含义为：  </p>
<ul>
<li><code>|</code>表示或</li>
<li><code>(...)</code>表示一组终结符或非终结符的组合</li>
<li><code>(...)*</code>表示0个或多个组合</li>
</ul>
<p>通过解释语法形成的句子来定义一种语言，解释的流程为：从开始符号为起点，反复使用规则主体替换非终结符，直到生成的句子仅包含终结符。该句子就构成了语法所定义的语言。<br>按照这种规则，如果语法无法派生出某个表达式，那么就说明该表达式不符合该语法。  </p>
<h2 id="从语法到代码的映射"><a href="#从语法到代码的映射" class="headerlink" title="从语法到代码的映射"></a>从语法到代码的映射</h2><p>以下是将语法映射成代码的规则：  </p>
<ol>
<li><p>为语法中定义的每条规则<code>R</code>，定义一个同名函数<code>R()</code>，函数的实现遵循该条语法规则的定义。例如将<code>expr  : factor((MUL|DIV)factor)*</code>转为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>或规则（如(a1|a2|…an)）映射为<code>if-elif-else</code>语句。例如将<code>(MUL|DIV)</code>转为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">token = self.current_token</span><br><span class="line"><span class="keyword">if</span> token.type == MUL:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>(...)*</code>规则映射为while语句。例如将<code>((MUL|DIV)factor)*</code>转为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>将规则中的每个token引用T映射为一个<code>eat(T)</code>的函数调用。<code>eat(T)</code>函数确认当前token的类型是否为T，如果是则继续解析下一个token，并赋给<code>current_token</code>。例如将<code>INTEGER</code>转为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.eat(INTEGER)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>于是对于本节初给出的语法例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr    : factor((MUL|DIV) factor)*</span><br><span class="line">factor  : INTEGER</span><br></pre></td></tr></table></figure></p>
<p>转成代码就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.factor()</span><br><span class="line">    <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">            self.eat(MUL)</span><br><span class="line">            self.factor()</span><br><span class="line">        <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">            self.eat(DIV)</span><br><span class="line">            self.factor()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.eat(INTEGER)</span><br></pre></td></tr></table></figure></p>
<p>Part4的代码用于解析上例中的语法，它将词法分析器和语法分析器分成两个类来定义，也使二者的职责更加明晰：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span>    <span class="comment"># 词法分析器</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advance</span><span class="params">(self)</span>:</span> <span class="comment"># 步进一个字符</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_whitespace</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integer</span><span class="params">(self)</span>:</span> <span class="comment"># 解析一个整型数</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">return</span> Token(EOF, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span>  <span class="comment"># 语法分析器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lexer)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self, token_type)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.current_token.type == token_type:</span><br><span class="line">            self.current_token = self.lexer.get_next_token()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        token = self.current_token</span><br><span class="line">        self.eat(INTEGER)</span><br><span class="line">        <span class="keyword">return</span> token.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>其中词法分析器<code>Lexer</code>的实现和前面章节没什么变化；主要是<code>Interpeter::expr(...)</code>使用了映射规则。</p>
<h1 id="考虑运算优先级"><a href="#考虑运算优先级" class="headerlink" title="考虑运算优先级"></a>考虑运算优先级</h1><p>乘除法的优先级高于加减法，怎么在语法中体现出该优先级呢？可以总结出2条规则：</p>
<ol>
<li>对每一级的运算，定义一条规则，左侧为本级非终结符，规则体包含本级的运算和更高级别的非终结符。</li>
<li>为最基本的元素创建一条规则，左侧为非终结符，右侧为该基本元素，如INTEGER。于是对于N级运算共有N+1条规则，每个级别一条+基本元素一条。</li>
</ol>
<p>将这两条规则应用于加减乘除四则运算，定义其语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr    : term((PLUS|MINUS)term)*</span><br><span class="line">term    : factor((MUL|DIV)factor)*</span><br><span class="line">factor  : INTEGER</span><br></pre></td></tr></table></figure></p>
<p>于是应用上一节由语法到代码的映射规则，转换代码为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isspace():</span><br><span class="line">                self.skip_whitespace()</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char.isdigit():</span><br><span class="line">                <span class="keyword">return</span> Token(INTEGER, self.integer())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'+'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(PLUS, <span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'-'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MINUS, <span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'*'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(MUL, <span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'/'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(DIV, <span class="string">'/'</span>)</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">                result = result * self.factor()</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">                result = result / self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)  <span class="comment"># 14 + 2 * </span></span><br><span class="line">                result = result + self.term() </span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">                result = result - self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
<p>以上是Part5引入的内容，重点是<code>Interpreter::term()</code>和<code>Interpreter::expr()</code>的变化。有了映射规则，代码很容易看懂；如果抛开规则直奔代码，难度将高出一个量级。</p>
<p>Part6只是在Part5的基础上支持了括号，语法被修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr    : term((PLUS|MINUS)term)*</span><br><span class="line">term    : factor((MUL|DIV)factor)*</span><br><span class="line">factor  : INTEGER | LPAREN expr RPAREN</span><br></pre></td></tr></table></figure></p>
<p>继续套用公式，只需要修改词法分析器对括号Token的解析和语法分析中factor函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lexer</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> self.current_char <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">'('</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(LPAREN, <span class="string">'('</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.current_char == <span class="string">')'</span>:</span><br><span class="line">                self.advance()</span><br><span class="line">                <span class="keyword">return</span> Token(RPAREN, <span class="string">')'</span>)</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == INTEGER:</span><br><span class="line">            self.eat(INTEGER)</span><br><span class="line">            <span class="keyword">return</span> token.value</span><br><span class="line">        <span class="keyword">elif</span> token.type == LPAREN: <span class="comment"># 如果遇到左括号</span></span><br><span class="line">            self.eat(LPAREN)</span><br><span class="line">            result = self.expr()</span><br><span class="line">            self.eat(RPAREN)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>几乎不需要思考。</p>
<h1 id="将语法解析和解释执行分离"><a href="#将语法解析和解释执行分离" class="headerlink" title="将语法解析和解释执行分离"></a>将语法解析和解释执行分离</h1><p>在Part7之前，语法解析和解释执行一直是合在一起的。这种解释其被称为<strong>语法导向解释器</strong>，这种解释器对源码只进行一次遍历，就直接得出结果，它适用于比较基本的语言处理程序。Part7开始将两部分分离开，第一步先构建出源码的<strong>中间表示形式Intermediate representation (IR)</strong>，第二步再对照IR执行。这方便应对更复杂的编程语言，语法解析器负责构建IR，解释器则负责执行IR。</p>
<p>通过IR对源代码构建起的数据结构称为<strong>抽象语法树abstract-syntax tree(AST)</strong>，AST的每个非叶子节点代表一个运算符，叶子节点代表一个操作数。优先级越高的运算，放在AST中越靠近叶子的层级。下图是一个AST的示例：<br><img src="/2018/06/18/2018/0618BuildASimpleInterpreter1/img06.png" alt></p>
<p>和Part6相比，主要变化为：<br>① 将Interpreter拆分为语法解析器Parser和解释器Interpreter<br>② 在Parser中<code>Parser::expr()</code>保持原先的逻辑框架，只是将原先的计算操作改为创建AST节点<br>③ 在Parser中按照语法解析每个非终结符时，原先的计算都改为创建一个AST节点<br>④ 在Interpreter中，它的主逻辑是<code>Interpreter::interprepret()</code>，负责后序遍历AST，计算结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AST</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, left, op, right)</span>:</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        self.token = token</span><br><span class="line">        self.value = token.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""term : factor ((MUL | DIV) factor)*"""</span></span><br><span class="line">        node = self.factor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (MUL, DIV):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == MUL:</span><br><span class="line">                self.eat(MUL)</span><br><span class="line">            <span class="keyword">elif</span> token.type == DIV:</span><br><span class="line">                self.eat(DIV)</span><br><span class="line">            <span class="comment"># ③ 将原先计算改为创建一个AST节点</span></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.factor())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line">            <span class="comment"># ③ 将原先计算改为创建一个AST节点</span></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self.expr()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        method_name = <span class="string">'visit_'</span> + type(node).__name__</span><br><span class="line">        visitor = getattr(self, method_name, self.generic_visit)</span><br><span class="line">        <span class="keyword">return</span> visitor(node)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span><span class="params">(NodeVisitor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parser)</span>:</span></span><br><span class="line">        self.parser = parser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_BinOp</span><span class="params">(self, node)</span>:</span> <span class="comment"># ④ 后序遍历AST</span></span><br><span class="line">        <span class="keyword">if</span> node.op.type == PLUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MINUS:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == MUL:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line">        <span class="keyword">elif</span> node.op.type == DIV:</span><br><span class="line">            <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Num</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interpret</span><span class="params">(self)</span>:</span></span><br><span class="line">        tree = self.parser.parse()</span><br><span class="line">        <span class="keyword">return</span> self.visit(tree)</span><br></pre></td></tr></table></figure></p>
<h1 id="支持一元操作"><a href="#支持一元操作" class="headerlink" title="支持一元操作"></a>支持一元操作</h1><p>一元操作包括+/-符号，一元操作的优先级高于二元操作。一个数字前面可以跟多个一元符号例如：<br><code>+-3 = +(-3) = -3</code><br><code>5--2 = 5 - (-2) = 7</code><br>于是可将语法修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr   : term ((PLUS | MINUS) term)*</span><br><span class="line">term   : factor ((MUL | DIV) factor)*</span><br><span class="line">factor : (PLUS | MINUS)factor | INTEGER | LPAREN expr RPAREN</span><br></pre></td></tr></table></figure></p>
<p>为factor添加了<code>(PLUS | MINUS)factor</code>。  </p>
<p>根据从语法到代码的转换规则，只需要修改语法解析器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryOp</span><span class="params">(AST)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, op, expr)</span>:</span></span><br><span class="line">        self.token = self.op = op</span><br><span class="line">        self.expr = expr</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN"""</span></span><br><span class="line">        token = self.current_token</span><br><span class="line">        <span class="keyword">if</span> token.type == PLUS:      <span class="comment"># 添加一元+的解析</span></span><br><span class="line">            self.eat(PLUS)</span><br><span class="line">            node = UnaryOp(token, self.factor())</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">elif</span> token.type == MINUS:   <span class="comment"># 添加一元-的解析</span></span><br><span class="line">            self.eat(MINUS)</span><br><span class="line">            node = UnaryOp(token, self.factor())</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">elif</span> token.type == INTEGER:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> token.type == LPAREN:</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        主框架保持不变</span></span><br><span class="line"><span class="string">        expr   : term ((PLUS | MINUS) term)*</span></span><br><span class="line"><span class="string">        term   : factor ((MUL | DIV) factor)*</span></span><br><span class="line"><span class="string">        factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.term()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.current_token.type <span class="keyword">in</span> (PLUS, MINUS):</span><br><span class="line">            token = self.current_token</span><br><span class="line">            <span class="keyword">if</span> token.type == PLUS:</span><br><span class="line">                self.eat(PLUS)</span><br><span class="line">            <span class="keyword">elif</span> token.type == MINUS:</span><br><span class="line">                self.eat(MINUS)</span><br><span class="line"></span><br><span class="line">            node = BinOp(left=node, op=token, right=self.term())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></p>
<h1 id="注重学习原理"><a href="#注重学习原理" class="headerlink" title="注重学习原理"></a>注重学习原理</h1><p>在Part2的开头，作者引用了Burger 和 Starbird在《The 5 Elements of Effective Thinking》这本书中讲述的一则故事。享誉世界的小号演奏家Tony Plog在一次大师班培训中，让学生们先演奏一首复杂的音乐片段，学生们演奏的很好；之后再让他们演奏一段非常基本简单的音乐，和前面的演奏相比听起来显得非常幼稚。演奏结束后，老师也演奏了一遍同样的乐段，但是老师的演奏却听不出幼稚——差异是明显的。Tony解释道：只有掌握演奏简单乐句的技巧，才能在演奏复杂乐句时更有掌控力。这则故事很有启发性：要培养真正的技艺，必须注重掌握简单的基本思想。正如艾默生所说：“如果你只学习方法，你将被绑死到方法上。如果你学习原理，你将可以自己设计适合自己的方法。”</p>
<p>正是出于这段文字，我才决定深入消化包含这14篇文章的编译器系列。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/随笔/" rel="tag"># 随笔</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/20/2018/0520MNISTForExperts/" rel="next" title="Deep MNIST for Experts代码分析">
                <i class="fa fa-chevron-left"></i> Deep MNIST for Experts代码分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/19/2018/0619BuildASimpleInterpreter2/" rel="prev" title="编写编译器和解释器二">
                编写编译器和解释器二 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2018/06/18/2018/0618BuildASimpleInterpreter1/" data-title="编写编译器和解释器一" data-url="http://palanceli.github.io/2018/06/18/2018/0618BuildASimpleInterpreter1/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/13184524" alt="Palance Li">
            
              <p class="site-author-name" itemprop="name">Palance Li</p>
              <p class="site-description motion-element" itemprop="description">学习，重生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">213</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/palanceli" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:palanceli@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/zchongr" target="_blank" title="我的CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>我的CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.cnblogs.com/palance/" target="_blank" title="我的博客园">
                      
                        <i class="fa fa-fw fa-globe"></i>我的博客园</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.jianshu.com/" target="_blank" title="我的简书">
                      
                        <i class="fa fa-fw fa-globe"></i>我的简书</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#我为什么关注它？"><span class="nav-number">1.</span> <span class="nav-text">我为什么关注它？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是编译器和解释器？"><span class="nav-number">2.</span> <span class="nav-text">什么是编译器和解释器？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#词法分析器"><span class="nav-number">3.</span> <span class="nav-text">词法分析器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part2"><span class="nav-number">3.1.</span> <span class="nav-text">Part2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#语法分析器"><span class="nav-number">4.</span> <span class="nav-text">语法分析器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#上下文无关文法和BNF表示法"><span class="nav-number">5.</span> <span class="nav-text">上下文无关文法和BNF表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从语法到代码的映射"><span class="nav-number">5.1.</span> <span class="nav-text">从语法到代码的映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#考虑运算优先级"><span class="nav-number">6.</span> <span class="nav-text">考虑运算优先级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#将语法解析和解释执行分离"><span class="nav-number">7.</span> <span class="nav-text">将语法解析和解释执行分离</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#支持一元操作"><span class="nav-number">8.</span> <span class="nav-text">支持一元操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注重学习原理"><span class="nav-number">9.</span> <span class="nav-text">注重学习原理</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Palance Li</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"palanceli"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


















  





  

  

  

  
  

  
  


  

  

</body>
</html>
